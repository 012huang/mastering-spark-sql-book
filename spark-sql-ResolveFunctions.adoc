== [[ResolveFunctions]] ResolveFunctions Logical Resolution Rule -- Resolving grouping__id UnresolvedAttribute, UnresolvedGenerator And UnresolvedFunction Expressions

`ResolveFunctions` is a logical resolution rule that the link:spark-sql-Analyzer.adoc#ResolveFunctions[logical query plan analyzer] uses to <<apply, resolve grouping__id UnresolvedAttribute, UnresolvedGenerator and UnresolvedFunction expressions>> in through an entire logical query plan.

Technically, `ResolveReferences` is just a link:spark-sql-catalyst-Rule.adoc[Catalyst rule] for transforming link:spark-sql-LogicalPlan.adoc[logical plans], i.e. `Rule[LogicalPlan]`.

`ResolveFunctions` is part of link:spark-sql-Analyzer.adoc#Resolution[Resolution] fixed-point batch of rules.

NOTE: `ResolveFunctions` is a Scala object inside `Analyzer` class.

[[example]]
[source, scala]
----
scala> spark.version
res0: String = 2.3.0

import spark.sessionState.analyzer.ResolveFunctions

CAUTION: FIXME

// Example: UnresolvedAttribute with VirtualColumn.hiveGroupingIdName (grouping__id) => Alias
val plan = ???
val resolvedPlan = ResolveFunctions(plan)

// Example: UnresolvedGenerator => a) Generator or b) analysis failure
val plan = ???
val resolvedPlan = ResolveFunctions(plan)

// Example: UnresolvedFunction => a) AggregateWindowFunction with(out) isDistinct, b) AggregateFunction, c) other with(out) isDistinct
val plan = ???
val resolvedPlan = ResolveFunctions(plan)
----

=== [[apply]] Resolving grouping__id UnresolvedAttribute, UnresolvedGenerator and UnresolvedFunction Expressions In Entire Query Plan (Applying ResolveFunctions to Logical Plan) -- `apply` Method

[source, scala]
----
apply(plan: LogicalPlan): LogicalPlan
----

NOTE: `apply` is a part of link:spark-sql-catalyst-Rule.adoc#apply[Rule Contract] to apply a rule to a link:spark-sql-LogicalPlan.adoc[logical plan].

`apply` takes a link:spark-sql-LogicalPlan.adoc[logical plan] and transforms each expression (for every logical operator found in the query plan) as follows:

1. For link:spark-sql-Expression-UnresolvedAttribute.adoc[UnresolvedAttributes] with link:spark-sql-Expression-UnresolvedAttribute.adoc#name[names] as `grouping__id`, `apply` creates a link:spark-sql-Expression-Alias.adoc#creating-instance[Alias] (with a `GroupingID` child expression and `grouping__id` name).
+
That case seems mostly for compatibility with Hive as `grouping__id` attribute name is used by Hive.

1. For link:spark-sql-Expression-UnresolvedGenerator.adoc[UnresolvedGenerators], `apply` requests the link:spark-sql-Analyzer.adoc#catalog[SessionCatalog] to link:spark-sql-SessionCatalog.adoc#lookupFunction[find a Generator function by name].
+
If some other non-generator function is found for the name, `apply` fails the analysis phase by reporting an `AnalysisException`:
+
```
[name] is expected to be a generator. However, its class is [className], which is not a generator.
```

1. For link:spark-sql-Expression-UnresolvedFunction.adoc[UnresolvedFunctions], `apply` requests the link:spark-sql-Analyzer.adoc#catalog[SessionCatalog] to link:spark-sql-SessionCatalog.adoc#lookupFunction[find a function by name].

* link:spark-sql-Expression-AggregateWindowFunction.adoc[AggregateWindowFunctions] are returned directly or `apply` fails the analysis phase by reporting an `AnalysisException` when the `UnresolvedFunction` has link:spark-sql-Expression-UnresolvedFunction.adoc#isDistinct[isDistinct] flag enabled.
+
```
[name] does not support the modifier DISTINCT
```

* link:spark-sql-Expression-AggregateFunction.adoc[AggregateFunctions] are wrapped in a link:spark-sql-Expression-AggregateExpression.adoc[AggregateExpression] (with `Complete` aggregate mode)

* All other functions are returned directly or `apply` fails the analysis phase by reporting an `AnalysisException` when the `UnresolvedFunction` has link:spark-sql-Expression-UnresolvedFunction.adoc#isDistinct[isDistinct] flag enabled.
+
```
[name] does not support the modifier DISTINCT
```

`apply` skips link:spark-sql-Expression.adoc#childrenResolved[unresolved expressions].
